# {{ app_name_ui }}

{{ app_description }}

## Table of Contents

- [Features](#features)
- [Requirements](#requirements)
- [Quick Start](#quick-start)
- [Project Structure](#project-structure)
- [Development Workflow](#development-workflow)
- [Middlewares](#middlewares)
- [Docker](#docker)
- [VPS Deployment](#vps-deployment)
- [Environment Variables](#environment-variables)
- [Testing](#testing)

## Features

- **FastAPI** - Modern, fast web framework with automatic API documentation
- **PostgreSQL** - Robust database with SQLAlchemy ORM and Alembic migrations
- **Type Safety** - Full type checking with Pyright and Pydantic
- **Structured Logging** - Comprehensive logging with Structlog and request correlation IDs
- **Security Middlewares**:
  - Rate limiting (SlowAPI)
  - Request ID tracking
  - DocShield (API docs protection in production)
  - CORS configuration
- **Testing** - Pytest with parallel execution and ASGI test client
{%- if enable_docker %}
- **Docker** - Multi-stage build with uv for optimal image size
{%- endif %}
{%- if enable_auth %}
- **Authentication** - Built-in user authentication with email verification
{%- endif %}
{%- if enable_soft_delete %}
- **Soft Delete** - Safe data deletion with recovery options
{%- endif %}
{%- if enable_vps_deployment %}
- **VPS Deployment** - PM2 process management with CI/CD workflows
{%- endif %}

## Requirements

- [uv](https://docs.astral.sh/uv/) (Python package manager)
- [PostgreSQL](https://www.postgresql.org/) (Database)
- [Git](https://git-scm.com/) (Version control)
{%- if enable_docker %}
- [Docker](https://www.docker.com/) & [Docker Compose](https://docs.docker.com/compose/) (Containerization)
{%- endif %}

## Quick Start

1. **Install dependencies**

```bash
uv sync --frozen
```

2. **Set up environment variables**

```bash
cp .env.example .env
# Edit .env with your configuration
```

3. **Set up the database**

```bash
scripts/setup_db.sh
```

4. **Run the application**

```bash
scripts/start_server.sh
```

The API will be available at `http://localhost:8000/` with interactive documentation at `http://localhost:8000/docs`.

## Project Structure

```
.
├── app/
│   ├── main.py              # Application entry point
│   ├── database/            # Database configuration
│   ├── dtos/                # Pydantic schemas
│   ├── middlewares/         # Request/response middlewares
│   ├── models/              # SQLAlchemy models
│   ├── routers/             # API route handlers
│   ├── services/            # Business logic
│   └── utils/               # Global utilities and settings
├── alembic/                 # Database migrations
├── scripts/                 # Utility scripts
├── test/                    # Test files
{%- if enable_docker %}
├── Dockerfile               # Docker image definition
├── docker-compose.yml       # Docker services
{%- endif %}
{% if enable_vps_deployment %}
├── pm2.config.js            # PM2 process configuration
{% endif %}
├── .env.example             # Environment variables template
├── pyproject.toml           # Dependencies and project config
└── pytest.ini               # Test configuration
```

## Development Workflow

### Adding a New Feature

1. **Create database model** 

```python
# app/models/example.py
from app.models.utils.utils import BaseMixin, StrColumn

class Example(BaseMixin):
    __tablename__ = "examples"
    
    name: Mapped[str] = mapped_column(StrColumn, nullable=False)
```

2. **Import model to alembic**
```python
# alembic/env.py
...
from app.models import example # noqa: F401
...
```

3. **Create migration**

```bash
uv run alembic revision --autogenerate -m "Add example table"
scripts/migrate_db.sh
```

4. **Create DTOs**

```python
# app/dtos/example.py
from pydantic import BaseModel
from pydantic_settings import ConfigDict

class ExampleCreateRequest(BaseModel):
    name: str

class ExampleResponse(BaseModel):
    id: str
    name: str

    model_config = ConfigDict(from_attributes=True)
```

5. **Create service**

```python
# app/services/example.py
from app.models.example import Example
from app.services.utils.utils import BaseService
from sqlalchemy.ext.asyncio import AsyncSession
from app.dtos.example import ExampleCreateRequest

class ExampleService(BaseService):
    def __init__(self, db: AsyncSession) -> None:
        self.db = db
    
    async def create_example(self, example_data: ExampleCreateRequest) -> Example:
        example = Example(name=example_data.name)
        await self.db.add(example)
        await self.db.flush()
        await self.db.refresh(example)
        return example
```

6. **Create service dependency**
```python
# app/utils/dependencies.py
...
ExampleServiceDependency = Annotated[
    ExampleService,
    Depends(lambda db=Depends(get_db_session): ExampleService(db=db)),
]
...
```

7. **Create router**

```python
# app/routers/example.py
from fastapi import APIRouter
from app.utils.dependencies import ExampleServiceDependency
from app.dtos.example import ExampleCreateRequest, ExampleResponse

router = APIRouter(prefix="/examples", tags=["examples"])

@router.post("/", )
async def create_example(example_data: ExampleCreateRequest, example_service: ExampleServiceDependency) -> ExampleResponse:
    """
    Create a new example.
    """
    example = await example_service.create_example(example_data=example_data)
    return ExampleResponse.model_validate(example)
```

8. **Register router**

```python
# app/routers/routes.py
from app.routers import example
...
api.router.include_router(example.router)
...
```

### Database Migrations

```bash
# Create a new migration
uv run alembic revision --autogenerate -m "description"

# Apply migrations
scripts/migrate_db.sh

# Rollback one migration
uv run alembic downgrade -1

# Reset database
scripts/reset_db.sh
```

### Running Tests

```bash
# Run all tests
scripts/test.sh

# Run specific test file
scripts/test.sh test/test_health.py
```

### Code Quality

```bash
# Format code
uv run ruff format .

# Lint code
uv run ruff check .

# Type check
uv run pyright

# Run pre-commit hooks
uv run pre-commit run --all-files
```

## Middlewares

The application includes several built-in middlewares:

### Logging Middleware
Logs all HTTP requests and responses with structured logging:
- Request method, path, headers, body
- Response status, processing time, body
- Automatic correlation ID for request tracking

### Rate Limiting
Protects your API from abuse with configurable rate limits:
```bash
# .env
RATE_LIMIT="60/minute"
```

### Request ID Tracking
Automatically adds correlation IDs to all requests for distributed tracing.

### DocShield
Protects API documentation in production with basic authentication:
```python
DOCS_ADMIN_USERNAME="admin"
DOCS_ADMIN_PASSWORD="password"
```

### CORS
Configurable CORS with environment-aware defaults:
- Development/Testing: Allows all origins
- Production: Restricted to specified origins

{% if enable_docker %}
## Docker

### Development with Docker Compose

```bash
# Start all services
docker-compose up -d

# View logs
docker-compose logs -f api

# Stop services
docker-compose down

# Rebuild after code changes
docker-compose up -d --build
```

### Production Docker Build

```bash
# Build image
docker build -t {{ app_name }}:latest .

# Run container
docker run -p 8000:8000 --env-file .env {{ app_name }}:latest
```

The Docker setup includes:
- Multi-stage build for minimal image size
- PostgreSQL database with health checks
- Automatic migrations on startup
- Volume mounts for logs and data persistence

### Docker Database
The docker container can either use the docker database service (default) in the [docker-compose.yml](./docker-compose.yml) or the host machine database.

- Docker database service: `POSTGRES_HOST=db`
- Host machine database: `POSTGRES_HOST=host.docker.internal`
{% endif %}

{% if enable_vps_deployment %}
## VPS Deployment

### Prerequisites

1. **Server setup:**
   - Ubuntu 20.04+ or similar Linux distribution
   - Node.js and PM2 installed
   - PostgreSQL database
   - SSH access configured

2. **GitHub Secrets (required):**
   - `SSH_PRIVATE_KEY` - Private SSH key for server access
   - `SSH_USER` - SSH username (e.g., `deploy`)
   - `SERVER_HOST` - Server IP or domain
   - `ENV_FILE` - Complete .env file contents for production

### Deployment Workflow

The CI/CD pipeline automatically deploys to production on pushes to `main`:

1. Runs tests and quality checks
2. Syncs code to server via rsync
3. Installs dependencies with uv
4. Runs database migrations
5. Restarts application with PM2
6. Performs health check

### Manual Deployment

```bash
# SSH into server
ssh user@your-server.com

# Navigate to app directory
cd /var/www/{{ app_name }}

# Pull latest code
git pull origin main

# Install dependencies
uv sync --no-dev --frozen

# Run migrations
scripts/migrate_db.sh

# Restart with PM2
pm2 restart {{ app_name }}
```

### PM2 Management

```bash
# View status
pm2 status

# View logs
pm2 logs {{ app_name }}

# Restart
pm2 restart {{ app_name }}

# Stop
pm2 stop {{ app_name }}
```
{% endif %}

## Environment Variables
Check out the [.env.example](./.env.example) file for a list of all available environment variables.

## Testing

The project uses pytest with the following features:

- **Parallel execution** - Tests run in parallel using pytest-xdist
- **ASGI test client** - Direct testing without running a server
- **Automatic retry** - Flaky tests are retried once

### Test Structure

```python
# test/test_example.py
import pytest
from httpx import AsyncClient
from test.utils.utils import assert_status_code

async def test_example_endpoint(client: AsyncClient, base_url: str):
    response = await client.get(f"{base_url}example/")
    assert_status_code(response, 200)
```

### Test Database

The tests run on a completely separate database named `{{ app_name }}-test`. You have to manually create the database and run the migrations before running the tests for the first time.

```bash
# Create database
DEPLOYMENT_ENVIRONMENT=testing scripts/create_db.sh

# Run migrations
DEPLOYMENT_ENVIRONMENT=testing scripts/migrate_db.sh

# Run tests
scripts/test.sh
```

## Scripts

Utility scripts in the `scripts/` directory:

- `start_server.sh` - Start the development server
- `test.sh` - Run tests with proper environment
- `create_db.sh` - Create the database
- `drop_db.sh` - Drop the database
- `migrate_db.sh` - Run pending migrations
- `reset_db.sh` - Drop then create database
- `context.sh` - Generate LLM context from code files


**Generated with** [create-fastapi-app](https://github.com/SenZmaKi/create-fastapi-app)
