from app.database import get_db_session
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.email import EmailService
from app.services.health import HealthService
from typing import Annotated
{% if enable_auth %}
from fastapi import Depends, Header, HTTPException, status
from app.models.auth import User
from app.services.auth import AuthService
{% else %}
from fastapi import Depends
{% endif %}

DBSessionDependency = Annotated[AsyncSession, Depends(get_db_session)]
HealthServiceDependency = Annotated[
    HealthService,
    Depends(lambda db=Depends(get_db_session): HealthService(db=db)),
]


{% if enable_auth %}
AuthServiceDependency = Annotated[
    AuthService,
    Depends(lambda db=Depends(get_db_session): AuthService(db=db)),
]
EmailServiceDependency = Annotated[
    EmailService,
    Depends(lambda db=Depends(get_db_session): EmailService(db=db)),
]

async def validate_session(
    session_token: str, auth_service: AuthService
) -> User | None:
    user = await auth_service.validate_session(session_token)
    if not user:
        return
    await auth_service.reset_session_expiration(session_token)
    return user


async def get_current_user(
    auth_service: AuthServiceDependency,
    authorization: Annotated[str | None, Header(alias="Authorization")] = None,
) -> User:
    """
    Dependency to get the current authenticated user from Authorization Bearer token.

    Raises:
        HTTPException: `HTTP 401 Unauthorized` If session is invalid
    """
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
    token = AuthService.parse_session_token(authorization)

    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

    user = await validate_session(token, auth_service)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired session",
            headers={"WWW-Authenticate": "Bearer"},
        )

    return user


async def get_optional_current_user(
    auth_service: AuthServiceDependency,
    authorization: Annotated[str | None, Header()] = None,
) -> User | None:
    """
    Dependency to optionally get the current authenticated user.
    Returns None if not authenticated
    """
    if not authorization:
        return None

    token = AuthService.parse_session_token(authorization)
    if not token:
        return None

    return await validate_session(token, auth_service)


async def get_verified_user(
    current_user: Annotated[User, Depends(get_current_user)],
) -> User:
    """
    Dependency to get the current authenticated user that has verified their email.

    Raises:
        HTTPException: `HTTP 403 Forbidden` If email is not verified
    """
    if not current_user.is_email_verified:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Please verify your email address to continue",
        )
    return current_user


CurrentUserDependency = Annotated[User, Depends(get_current_user)]
VerifiedUserDependency = Annotated[User, Depends(get_verified_user)]
OptionalCurrentUserDependency = Annotated[
    User | None, Depends(get_optional_current_user)
]
{% endif %}